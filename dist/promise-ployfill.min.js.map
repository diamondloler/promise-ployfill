{"version":3,"sources":["promise.js"],"names":["root","factory","define","amd","exports","_typeof","module","global","window","undefined","isFunction","v","asyncTask","process","nextTick","setImmediate","setTimeout","isInstance","obj","PromisePolyfill","resolver","fulfilled","rejected","isThenAble","deferreds","this","then","onResolve","onReject","Error","push","call","resolve","reject","result","deferred","createMutationHandler","type","cb","value","popDeferredsStack","arr","length","shift","onInnerPromiseFulfilled","res","onInnerPromiseRejected","err","all","queue","Array","isArray","item","_resolve","results","i","consume","done","onResolved","mutationProxy","onRejected","ins","isReject","index","key","findIndex","untilDone","apply","bind","ocurrError","resovle","next","slice","arguments","console","warn","fn","error","race","onMutated","data","Promise"],"mappings":"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","file":"promise-ployfill.min.js","sourcesContent":["(function (root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(function () {\r\n            return factory(root);\r\n        });\r\n    } else if (typeof exports === \"object\" && typeof module !== \"undefined\") {\r\n        module.exports = factory(root);\r\n    } else {\r\n        factory(root)\r\n    }\r\n})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this, function (window) {\r\n\r\n    var isFunction = function (v) {\r\n        return typeof v === 'function'\r\n    }\r\n\r\n    var asyncTask = (function () {\r\n        return typeof process === 'object' &&\r\n            process !== null &&\r\n            typeof process.nextTick === 'function' &&\r\n            process.nextTick ||\r\n            typeof setImmediate === 'function' &&\r\n            setImmediate ||\r\n            setTimeout;\r\n    })()\r\n\r\n    var findIndex = function (arr, key) {\r\n        for (var i = 0; i < arr.length; i++) {\r\n            if (arr[i] == key) return i\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n    var isInstance = function (obj) {\r\n        return obj && obj instanceof PromisePolyfill\r\n    }\r\n\r\n\r\n    var PromisePolyfill = function (resolver) {\r\n\r\n        var fulfilled = false\r\n        var rejected = false\r\n\r\n        // when resolver trigger reject , isThenAble is false, stop chain calls\r\n        var isThenAble = false\r\n\r\n        // 延迟队列\r\n        var deferreds = []\r\n\r\n        // onfulfilled or onrejected callback push deferreds stack\r\n        this.then = function (onResolve, onReject) {\r\n            if (isFunction(onResolve) || isFunction(onReject)) {\r\n                deferreds.push({\r\n                    onResolve: onResolve || null,\r\n                    onReject: onReject || null\r\n                })\r\n                isThenAble = true\r\n            } else {\r\n                throw new Error('the arguments of \\\"promise.then\\\" can\\'t be empty');\r\n            }\r\n\r\n            // async/await compatibility\r\n            resolver && resolver.call(null, resolve, reject)\r\n\r\n            return this\r\n        }\r\n\r\n\r\n        //create async mutation handler\r\n        var createMutationHandler = function (type, cb) {\r\n            return function (value) {\r\n                if (value instanceof PromisePolyfill) {\r\n                    throw new Error('the value of ' + type + ' should not construtor itself')\r\n                }\r\n                if (!value) return\r\n                asyncTask(function () {\r\n                    isThenAble && isFunction(cb) && cb.call(null, value)\r\n                })\r\n            }\r\n        }\r\n\r\n        var popDeferredsStack = function (arr) {\r\n            return arr.length == 0 ? {} : arr.shift()\r\n        }\r\n\r\n        // mark the result of onResolve \r\n        var result\r\n        // deferred object\r\n        var deferred\r\n\r\n        //通过内部promise实例resolve的数据，消费当前实例内部的延时队列\r\n        var onInnerPromiseFulfilled = function (res) {\r\n            resolve(res)\r\n        }\r\n\r\n        var onInnerPromiseRejected = function (err) {\r\n            reject(err)\r\n        }\r\n\r\n        var resolve = createMutationHandler('resolve', function (value) {\r\n            if (rejected) throw Error('can\\'t not call resolve, promise is already rejected')\r\n\r\n            if (!deferreds.length) return\r\n\r\n            deferred = popDeferredsStack(deferreds)\r\n\r\n            result = deferred.onResolve && deferred.onResolve(value)\r\n\r\n            fulfilled = true\r\n\r\n            if (isInstance(result)) {\r\n                isThenAble = true\r\n                result.then(onInnerPromiseFulfilled, onInnerPromiseRejected)\r\n            }\r\n\r\n        })\r\n\r\n        var reject = createMutationHandler('reject', function (value) {\r\n            if (fulfilled) throw Error('can\\'t not call reject, promise is already fulfilled')\r\n\r\n            deferred = popDeferredsStack(deferreds)\r\n\r\n            deferred.onReject && deferred.onReject(value)\r\n\r\n            rejected = true\r\n            isThenAble = false\r\n        })\r\n    }\r\n\r\n\r\n    PromisePolyfill.all = function (queue) {\r\n        if (!Array.isArray(queue)) return;\r\n\r\n        var results = []\r\n        var i = queue.length\r\n        var consume = i\r\n        var done = false\r\n        var item, _resolve\r\n\r\n        var onResolved = function (res) {\r\n            mutationProxy(res, this)\r\n        }\r\n\r\n        var onRejected = function (err) {\r\n            mutationProxy(err, this, true)\r\n        }\r\n\r\n        var mutationProxy = function (v, ins, isReject) {\r\n            if (done) return\r\n\r\n            var index = findIndex(queue, ins)\r\n            if (index === false) return\r\n            results[index] = v\r\n\r\n            var args = isReject ? [results, true] : [results]\r\n\r\n            untilDone.apply(null, args)\r\n        }\r\n\r\n\r\n        function untilDone(result, ocurrError) {\r\n            consume--\r\n\r\n            if (ocurrError || !consume) {\r\n                _resolve(result)\r\n                done = true\r\n            }\r\n        }\r\n\r\n\r\n        while (i--) {\r\n            item = queue[i]\r\n            if (isInstance(item)) {\r\n                item.then(onResolved.bind(item), onRejected.bind(item))\r\n            } else if (isFunction(item)) {\r\n                //       \r\n                continue;\r\n            } else {\r\n                // ordinary value    \r\n                results[i] = item\r\n                untilDone(results)\r\n            };\r\n        }\r\n\r\n\r\n        return new PromisePolyfill((resolve) => {\r\n            _resolve = resolve\r\n        })\r\n    }\r\n\r\n\r\n    PromisePolyfill.resolve = function (v) {\r\n        return isInstance(v) ?\r\n            v :\r\n            new PromisePolyfill(function (resovle) {\r\n                resovle(v || 'fulfilled')\r\n            })\r\n    }\r\n\r\n    PromisePolyfill.reject = function (v) {\r\n        return new PromisePolyfill(function (resovle, reject) {\r\n            reject(v || 'rejected')\r\n        })\r\n    }\r\n\r\n\r\n    PromisePolyfill.next = function () {\r\n        var queue = [].slice.call(arguments)\r\n\r\n        function next(res, err) {\r\n            if (err) {\r\n                //console the error from previous loop include (async, sync)\r\n                return console.warn(err)\r\n            }\r\n\r\n            if (!queue.length) {\r\n                //execluted all of queue \r\n                return;\r\n            }\r\n\r\n            var fn = queue.shift()\r\n\r\n            if (isFunction(fn)) {\r\n                try {\r\n                    res !== void 0 ? fn.call(null, next, res) : fn.call(null, next)\r\n                } catch (error) {\r\n                    //catch sync error\r\n                    next(null, error)\r\n                }\r\n            }\r\n        }\r\n\r\n        next()\r\n    }\r\n\r\n\r\n    PromisePolyfill.race = function (queue) {\r\n        if (!Array.isArray(queue)) return;\r\n        var _resolve\r\n        var i = queue.length\r\n        var item\r\n\r\n        var onMutated = function (data) {\r\n            _resolve(data)\r\n        }\r\n\r\n        while (i--) {\r\n            item = queue[i]\r\n            if (isInstance(item)) {\r\n                item.then(onMutated, onMutated)\r\n            }\r\n        }\r\n\r\n        return new PromisePolyfill(function (resovle) {\r\n            _resolve = resovle\r\n        })\r\n    }\r\n\r\n    return typeof window.Promise === 'undefined' && (window.Promise = PromisePolyfill)\r\n})\r\n"]}