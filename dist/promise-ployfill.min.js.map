{"version":3,"sources":["promise.js"],"names":["root","factory","module","exports","define","amd","global","window","this","isFunction","v","asyncTask","process","nextTick","setImmediate","setTimeout","isInstance","obj","PromisePolyfill","resolver","fulfilled","rejected","isThenAble","deferreds","then","onResolve","onReject","Error","push","call","resolve","reject","result","deferred","createMutationHandler","type","cb","value","popDeferredsStack","arr","length","shift","onInnerPromiseFulfilled","res","onInnerPromiseRejected","err","all","queue","Array","isArray","item","_resolve","results","i","consume","done","onResolved","mutationProxy","onRejected","ins","isReject","index","key","findIndex","untilDone","apply","bind","ocurrError","resovle","next","slice","arguments","console","warn","fn","error","race","onMutated","data","Promise"],"mappings":"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","file":"promise-ployfill.min.js","sourcesContent":["(function (root, factory) {\r\n    if (typeof module === \"object\") {\r\n        module.exports = factory(root);\r\n    } else if (typeof define === 'function' && define.amd) {\r\n        define(function () {\r\n            return factory(root);\r\n        });\r\n    } else {\r\n        factory(root)\r\n    }\r\n})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this, function (window) {\r\n\r\n    var isFunction = function (v) {\r\n        return typeof v === 'function'\r\n    }\r\n\r\n    var asyncTask = (function () {\r\n        return typeof process === 'object' &&\r\n            process !== null &&\r\n            typeof process.nextTick === 'function' &&\r\n            process.nextTick ||\r\n            typeof setImmediate === 'function' &&\r\n            setImmediate ||\r\n            setTimeout;\r\n    })()\r\n\r\n    var findIndex = function (arr, key) {\r\n        for (var i = 0; i < arr.length; i++) {\r\n            if (arr[i] == key) return i\r\n        }\r\n        return false\r\n    }\r\n\r\n\r\n    var isInstance = function (obj) {\r\n        return obj && obj instanceof PromisePolyfill\r\n    }\r\n\r\n\r\n    var PromisePolyfill = function (resolver) {\r\n\r\n        var fulfilled = false\r\n        var rejected = false\r\n\r\n        // when resolver trigger reject , isThenAble is false, stop chain calls\r\n        var isThenAble = false\r\n\r\n        // 延迟队列\r\n        var deferreds = []\r\n\r\n        // onfulfilled or onrejected callback push deferreds stack\r\n        this.then = function (onResolve, onReject) {\r\n            if (isFunction(onResolve) || isFunction(onReject)) {\r\n                deferreds.push({\r\n                    onResolve: onResolve || null,\r\n                    onReject: onReject || null\r\n                })\r\n                isThenAble = true\r\n            } else {\r\n                throw new Error('the arguments of \\\"promise.then\\\" can\\'t be empty');\r\n            }\r\n\r\n            // async/await compatibility\r\n            resolver && resolver.call(null, resolve, reject)\r\n\r\n            return this\r\n        }\r\n\r\n\r\n        //create async mutation handler\r\n        var createMutationHandler = function (type, cb) {\r\n            return function (value) {\r\n                if (value instanceof PromisePolyfill) {\r\n                    throw new Error('the value of ' + type + ' should not construtor itself')\r\n                }\r\n\r\n                if (!value) return\r\n\r\n                asyncTask(function () {\r\n                    isThenAble && isFunction(cb) && cb.call(null, value)\r\n                })\r\n            }\r\n        }\r\n\r\n        var popDeferredsStack = function (arr) {\r\n            return arr.length == 0 ? {} : arr.shift()\r\n        }\r\n\r\n        // mark the result of onResolve \r\n        var result\r\n        // deferred object\r\n        var deferred\r\n\r\n        //通过内部promise实例resolve的数据，消费当前实例延时队列\r\n        var onInnerPromiseFulfilled = function (res) {\r\n            resolve(res)\r\n        }\r\n\r\n        var onInnerPromiseRejected = function (err) {\r\n            reject(err)\r\n        }\r\n\r\n        var resolve = createMutationHandler('resolve', function (value) {\r\n            if (!deferreds.length) return\r\n            \r\n            if (rejected) throw Error('can\\'t not call resolve, promise is already rejected')\r\n\r\n            deferred = popDeferredsStack(deferreds)\r\n            result = deferred.onResolve && deferred.onResolve(value)\r\n\r\n            fulfilled = true\r\n            isThenAble = true\r\n\r\n            if (isInstance(result)) {\r\n                result.then(onInnerPromiseFulfilled, onInnerPromiseRejected)\r\n            } else { \r\n                // empty deferreds if result of ins.then not a instance of Promise \r\n                // and continue call then in the chain\r\n                resolve()\r\n            }\r\n\r\n        })\r\n\r\n        var reject = createMutationHandler('reject', function (value) {\r\n            if (fulfilled) throw Error('can\\'t not call reject, promise is already fulfilled')\r\n\r\n            deferred = popDeferredsStack(deferreds)\r\n            deferred.onReject && deferred.onReject(value)\r\n\r\n            rejected = true\r\n            isThenAble = false\r\n        })\r\n    }\r\n\r\n\r\n    PromisePolyfill.all = function (queue) {\r\n        if (!Array.isArray(queue)) return;\r\n\r\n        var results = []\r\n        var i = queue.length\r\n        var consume = i\r\n        var done = false\r\n        var item, _resolve\r\n\r\n        var onResolved = function (res) {\r\n            mutationProxy(res, this)\r\n        }\r\n\r\n        var onRejected = function (err) {\r\n            mutationProxy(err, this, true)\r\n        }\r\n\r\n        var mutationProxy = function (v, ins, isReject) {\r\n            if (done) return\r\n\r\n            var index = findIndex(queue, ins)\r\n            if (index === false) return\r\n            results[index] = v\r\n\r\n            var args = isReject ? [results, true] : [results]\r\n\r\n            untilDone.apply(null, args)\r\n        }\r\n\r\n\r\n        function untilDone(result, ocurrError) {\r\n            consume--\r\n\r\n            if (ocurrError || !consume) {\r\n                _resolve(result)\r\n                done = true\r\n            }\r\n        }\r\n\r\n\r\n        while (i--) {\r\n            item = queue[i]\r\n            if (isInstance(item)) {\r\n                item.then(onResolved.bind(item), onRejected.bind(item))\r\n            } else if (isFunction(item)) {\r\n                //       \r\n                continue;\r\n            } else {\r\n                // ordinary value    \r\n                results[i] = item\r\n                untilDone(results)\r\n            };\r\n        }\r\n\r\n\r\n        return new PromisePolyfill(function (resolve) {\r\n            _resolve = resolve\r\n        })\r\n    }\r\n\r\n\r\n    PromisePolyfill.resolve = function (v) {\r\n        return isInstance(v) ?\r\n            v :\r\n            new PromisePolyfill(function (resovle) {\r\n                resovle(v || 'fulfilled')\r\n            })\r\n    }\r\n\r\n    PromisePolyfill.reject = function (v) {\r\n        return new PromisePolyfill(function (resovle, reject) {\r\n            reject(v || 'rejected')\r\n        })\r\n    }\r\n\r\n\r\n    PromisePolyfill.next = function () {\r\n        var queue = [].slice.call(arguments)\r\n\r\n        function next(err, res) {\r\n            if (err) {\r\n                //console the error from previous loop include (async, sync)\r\n                return console.warn(err)\r\n            }\r\n\r\n            if (!queue.length) {\r\n                //execluted all of queue \r\n                return;\r\n            }\r\n\r\n            var fn = queue.shift()\r\n\r\n            if (isFunction(fn)) {\r\n                try {\r\n                    res !== void 0 ? fn.call(null, next, res) : fn.call(null, next)\r\n                } catch (error) {\r\n                    \r\n                    //catch sync error\r\n                    next(error)\r\n                }\r\n            }\r\n        }\r\n\r\n        next()\r\n    }\r\n\r\n\r\n    PromisePolyfill.race = function (queue) {\r\n        if (!Array.isArray(queue)) return;\r\n        var _resolve\r\n        var i = queue.length\r\n        var item\r\n\r\n        var onMutated = function (data) {\r\n            _resolve(data)\r\n        }\r\n\r\n        while (i--) {\r\n            item = queue[i]\r\n            if (isInstance(item)) {\r\n                item.then(onMutated, onMutated)\r\n            }\r\n        }\r\n\r\n        return new PromisePolyfill(function (resovle) {\r\n            _resolve = resovle\r\n        })\r\n    }\r\n\r\n    return window.Promise || (window.Promise = PromisePolyfill)\r\n})\r\n"]}